<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>KOG Player Stats</title>
    <style>
      :root {
        color-scheme: dark;
        --bg-gradient: radial-gradient(circle at top, #151a33 0%, #05070e 55%, #010103 100%);
        --card-bg: rgba(12, 16, 34, 0.75);
        --card-border: rgba(82, 93, 150, 0.35);
        --glow: 0 24px 60px rgba(16, 26, 67, 0.55);
        --accent: #46c2ff;
        --accent-soft: rgba(70, 194, 255, 0.18);
        --text-primary: #f3f6ff;
        --text-muted: #9aa4c7;
        --divider: rgba(90, 105, 158, 0.35);
        --badge-bg: rgba(70, 194, 255, 0.12);
        --badge-text: #7fd6ff;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Inter", system-ui, -apple-system, Segoe UI, sans-serif;
        background: var(--bg-gradient);
        color: var(--text-primary);
        padding: clamp(1.6rem, 4vw, 3.5rem);
        display: flex;
        justify-content: center;
      }

      main {
        width: min(1100px, 100%);
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 28px;
        box-shadow: var(--glow);
        backdrop-filter: blur(20px);
        padding: clamp(1.6rem, 3vw, 3rem);
        position: relative;
        overflow: hidden;
      }

      main::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: radial-gradient(circle at 25% 15%, rgba(70, 194, 255, 0.22), transparent 55%),
          radial-gradient(circle at 80% 0%, rgba(125, 214, 255, 0.12), transparent 60%);
        filter: blur(0.5px);
      }

      header {
        position: relative;
        z-index: 1;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 1.5rem;
        margin-bottom: clamp(1.8rem, 3vw, 2.8rem);
      }

      .team-lockup {
        display: flex;
        align-items: center;
        gap: clamp(0.9rem, 2vw, 1.4rem);
      }

      .team-lockup__text {
        display: grid;
        gap: 0.45rem;
      }

      .team-logo {
        width: clamp(64px, 12vw, 92px);
        height: clamp(64px, 12vw, 92px);
        object-fit: cover;
        border-radius: 50%;
        border: 2px solid rgba(70, 194, 255, 0.35);
        box-shadow: 0 12px 28px rgba(16, 32, 72, 0.45);
        background: rgba(4, 6, 14, 0.6);
      }

      .team-lockup h1 {
        font-size: clamp(2.1rem, 4vw, 2.9rem);
        letter-spacing: 0.04em;
        text-transform: uppercase;
        margin: 0;
      }

      .team-lockup span {
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.4em;
        color: var(--text-muted);
      }

      .meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.7rem;
        z-index: 1;
      }

      .badge {
        padding: 0.45rem 0.85rem;
        border-radius: 999px;
        border: 1px solid var(--accent-soft);
        background: var(--badge-bg);
        color: var(--badge-text);
        font-size: 0.8rem;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        letter-spacing: 0.08em;
      }

      .badge strong {
        font-weight: 600;
        color: var(--text-primary);
      }

      .badge--hero {
        padding: 0.7rem 1.4rem;
        font-size: 1.05rem;
        letter-spacing: 0.06em;
        color: #12263e;
        background: linear-gradient(130deg, #f8d057, #ffd97a);
        border: none;
        box-shadow: 0 14px 32px rgba(255, 207, 87, 0.35);
      }

      .badge--hero strong {
        color: #10233b;
      }

      section {
        position: relative;
        z-index: 1;
      }

      .table-wrapper {
        overflow-x: auto;
        border-radius: 20px;
        border: 1px solid rgba(96, 108, 162, 0.25);
        background: rgba(7, 10, 22, 0.65);
        box-shadow: inset 0 1px 0 rgba(108, 124, 182, 0.25);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 720px;
      }

      th.sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
      }

      th.sortable::after {
        content: "";
        position: absolute;
        right: 0.6rem;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.7rem;
        color: var(--text-muted);
      }

      th.sortable[data-active="true"][data-direction="desc"]::after {
        content: "â–¼";
      }

      th.sortable[data-active="true"][data-direction="asc"]::after {
        content: "â–²";
      }

      thead {
        background: linear-gradient(95deg, rgba(70, 194, 255, 0.18), rgba(70, 194, 255, 0.05));
      }

      th,
      td {
        padding: 1rem 1.25rem;
        text-align: right;
        font-size: 0.92rem;
      }

      th {
        text-transform: uppercase;
        letter-spacing: 0.2em;
        font-size: 0.72rem;
        color: var(--text-muted);
        font-weight: 600;
      }

      th:first-child,
      td:first-child,
      th:nth-child(2),
      td:nth-child(2) {
        text-align: left;
      }

      tbody tr {
        border-bottom: 1px solid var(--divider);
        transition: background 180ms ease, transform 180ms ease;
        cursor: pointer;
      }

      tbody tr:last-child {
        border-bottom: none;
      }

      tbody tr:hover {
        background: rgba(70, 194, 255, 0.06);
        transform: translateY(-2px);
      }

      tbody td {
        color: var(--text-primary);
      }

      tbody td span {
        display: block;
        color: var(--text-muted);
        font-size: 0.78rem;
        letter-spacing: 0.02em;
      }

      .number {
        font-weight: 600;
        color: var(--accent);
      }

      .highlight {
        color: #f8d057;
        font-weight: 600;
        text-shadow: 0 0 16px rgba(255, 210, 95, 0.45);
      }

      .totals {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
        margin-bottom: 1.8rem;
        position: relative;
        z-index: 1;
      }

      .totals-card {
        border: 1px solid rgba(96, 108, 162, 0.22);
        background: rgba(9, 12, 26, 0.65);
        border-radius: 18px;
        padding: 1rem 1.2rem;
        display: grid;
        gap: 0.35rem;
      }

      .totals-card.card-clickable {
        cursor: pointer;
        transition: transform 150ms ease, border 150ms ease;
      }

      .totals-card.card-clickable:hover {
        transform: translateY(-3px);
        border-color: rgba(125, 214, 255, 0.45);
      }

      .totals-card span {
        color: var(--text-muted);
        font-size: 0.8rem;
        letter-spacing: 0.16em;
        text-transform: uppercase;
      }

      .totals-card strong {
        font-size: 1.6rem;
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .totals-card p {
        margin: 0;
        color: var(--text-muted);
        font-size: 0.78rem;
        letter-spacing: 0.04em;
      }

      .schedule {
        margin-top: clamp(2.4rem, 6vw, 3.4rem);
        display: grid;
        gap: 1.6rem;
      }

      .schedule-title {
        margin: 0;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        letter-spacing: 0.26em;
        text-transform: uppercase;
        color: var(--text-muted);
      }

      .next-game-wrapper {
        display: none;
      }

      .next-game-wrapper.active {
        display: block;
      }

      .games-group {
        display: grid;
        gap: 0.85rem;
      }

      .games-group h3 {
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.24em;
        font-size: 0.78rem;
        color: var(--text-muted);
      }

      .games-list {
        display: grid;
        gap: 0.8rem;
      }

      .game-card {
        border: 1px solid rgba(96, 108, 162, 0.24);
        background: rgba(7, 10, 22, 0.62);
        border-radius: 18px;
        padding: 1rem 1.2rem;
        display: grid;
        gap: 0.65rem;
        box-shadow: inset 0 1px 0 rgba(70, 194, 255, 0.12);
      }

      .game-card--next {
        border-color: rgba(125, 214, 255, 0.48);
        background: rgba(15, 32, 58, 0.78);
        box-shadow: 0 18px 44px rgba(24, 61, 123, 0.32);
      }

      .game-card__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .game-card__label {
        font-size: 0.78rem;
        letter-spacing: 0.24em;
        text-transform: uppercase;
        color: var(--badge-text);
      }

      .game-card__homeaway {
        font-size: 0.72rem;
        letter-spacing: 0.22em;
        text-transform: uppercase;
        padding: 0.32rem 0.95rem;
        border-radius: 999px;
        border: 1px solid rgba(96, 108, 162, 0.42);
        color: var(--text-muted);
      }

      .game-card__homeaway.is-home {
        border-color: rgba(125, 214, 255, 0.45);
        color: var(--accent);
      }

      .game-card__homeaway.is-away {
        border-color: rgba(255, 210, 95, 0.45);
        color: #ffd97a;
      }

      .game-card__opponent {
        font-size: clamp(1.15rem, 3vw, 1.35rem);
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .game-card__meta {
        font-size: 0.86rem;
        letter-spacing: 0.06em;
        color: var(--text-muted);
      }

      .game-card__score {
        display: inline-flex;
        align-items: baseline;
        gap: 0.45rem;
        font-size: clamp(1.6rem, 3vw, 1.9rem);
        font-weight: 600;
        letter-spacing: 0.08em;
      }

      .game-card__score-sep {
        font-size: 1rem;
        color: var(--text-muted);
      }

      .game-card__result {
        text-transform: uppercase;
        letter-spacing: 0.2em;
        font-size: 0.78rem;
      }

      .game-card__result--win {
        color: #7fd6ff;
      }

      .game-card__result--loss {
        color: #ff8c8c;
      }

      .game-card__result--draw {
        color: var(--text-muted);
      }

      .game-card__countdown {
        font-size: 0.84rem;
        letter-spacing: 0.08em;
        color: var(--badge-text);
      }

      .team-photo {
        margin-top: clamp(2.4rem, 6vw, 3.4rem);
        display: flex;
        justify-content: center;
      }

      .team-photo img {
        width: min(460px, 90%);
        border-radius: 22px;
        border: 2px solid rgba(70, 194, 255, 0.25);
        box-shadow: 0 20px 48px rgba(12, 26, 66, 0.45);
        object-fit: cover;
      }

      .links-card {
        margin-top: clamp(2rem, 5vw, 2.8rem);
        border: 1px solid rgba(96, 108, 162, 0.28);
        border-radius: 20px;
        background: rgba(6, 9, 20, 0.62);
        padding: clamp(1.2rem, 3vw, 1.8rem);
        display: grid;
        gap: 1rem;
      }

      .links-card h3 {
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.28em;
        font-size: 0.78rem;
        color: var(--text-muted);
      }

      .links-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
      }

      .links-list a {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.55rem 1rem;
        border-radius: 999px;
        border: 1px solid rgba(70, 194, 255, 0.26);
        color: var(--badge-text);
        text-decoration: none;
        letter-spacing: 0.08em;
        font-size: 0.82rem;
        transition: border 150ms ease, color 150ms ease, transform 150ms ease;
      }

      .links-list a:hover {
        border-color: rgba(125, 214, 255, 0.45);
        color: var(--accent);
        transform: translateY(-1px);
      }

      .no-data {
        margin-top: 1.6rem;
        padding: 1.1rem 1.3rem;
        border-radius: 14px;
        border: 1px dashed rgba(70, 194, 255, 0.42);
        background: rgba(4, 7, 18, 0.65);
        color: var(--badge-text);
        font-size: 0.88rem;
        display: none;
      }

      @media (max-width: 768px) {
        main {
          border-radius: 22px;
        }

        header {
          flex-direction: column;
          align-items: flex-start;
        }

        thead {
          position: sticky;
          top: 0;
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 1.2rem;
        }

        .team-lockup {
          flex-direction: column;
          align-items: center;
          gap: 0.8rem;
        }

        .team-lockup__text {
          text-align: center;
        }

        .team-logo {
          width: clamp(60px, 24vw, 78px);
          height: clamp(60px, 24vw, 78px);
        }

        .team-lockup h1 {
          font-size: clamp(1.8rem, 8vw, 2.2rem);
        }

        th,
        td {
          padding: 0.7rem 0.85rem;
          font-size: 0.84rem;
        }

        th {
          font-size: 0.66rem;
          letter-spacing: 0.16em;
        }

        tbody td span {
          font-size: 0.7rem;
        }

        .badge {
          font-size: 0.7rem;
          letter-spacing: 0.06em;
        }
      }

      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(4, 6, 14, 0.75);
        backdrop-filter: blur(14px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 20;
        padding: 1.2rem;
        overflow-y: auto;
      }

      .modal-overlay.visible {
        display: flex;
      }

      .modal-card {
        width: min(420px, 100%);
        background: rgba(8, 12, 26, 0.9);
        border: 1px solid rgba(108, 132, 205, 0.4);
        border-radius: 22px;
        padding: clamp(1.4rem, 4vw, 2rem);
        box-shadow: 0 22px 58px rgba(8, 12, 32, 0.55);
        display: grid;
        gap: 1rem;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        position: sticky;
        top: 0;
        padding-top: 0.2rem;
        padding-bottom: 0.6rem;
        background: rgba(8, 12, 26, 0.95);
        z-index: 1;
      }

      .modal-header h2 {
        margin: 0;
        font-size: clamp(1.4rem, 5vw, 1.9rem);
        letter-spacing: 0.05em;
      }

      .close-modal {
        appearance: none;
        border: 1px solid rgba(108, 132, 205, 0.35);
        background: rgba(10, 14, 31, 0.6);
        color: var(--text-muted);
        border-radius: 999px;
        padding: 0.45rem 0.95rem;
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 150ms ease, color 150ms ease;
      }

      .close-modal:hover {
        background: rgba(78, 126, 255, 0.18);
        color: var(--text-primary);
      }

      .modal-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
      }

      .modal-stats {
        display: grid;
        gap: 0.9rem;
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        font-size: 1.02rem;
        letter-spacing: 0.02em;
      }

      .modal-card--wide {
        width: min(760px, 100%);
      }
      @media (max-width: 720px) {
        .modal-overlay {
          align-items: flex-start;
          padding: 0.7rem;
        }
        .modal-card {
          width: 100%;
          border-radius: 16px;
          padding: 1.2rem;
          max-height: calc(100vh - 1.4rem);
        }
        .timeline-body {
          max-height: 55vh;
        }
      }

      .timeline-controls {
        display: flex;
        margin-bottom: 0.6rem;
      }

      .timeline-controls input[type="search"] {
        width: 100%;
        padding: 0.55rem 0.8rem;
        border-radius: 12px;
        border: 1px solid rgba(96, 108, 162, 0.4);
        background: rgba(10, 14, 30, 0.8);
        color: var(--text-primary);
      }

      .timeline-meta {
        color: var(--text-muted);
        font-size: 0.95rem;
        display: flex;
        gap: 0.8rem;
        flex-wrap: wrap;
      }

      .timeline-body {
        border: 1px solid rgba(96, 108, 162, 0.25);
        background: rgba(6, 9, 20, 0.65);
        border-radius: 16px;
        padding: 1rem 1.1rem;
        max-height: min(60vh, 520px);
        overflow-y: auto;
        display: grid;
        gap: 0.8rem;
      }
      .timeline-summary {
        margin-top: 12px;
        padding: 12px;
        background: #fff6c2;
        border: 1px solid #f0c948;
        border-radius: 12px;
      }
      .timeline-summary__title {
        font-size: 0.9rem;
        font-weight: 800;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: #7d5b00;
        margin-bottom: 6px;
      }
      .timeline-summary__rows {
        display: grid;
        gap: 6px;
      }
      .timeline-summary__row {
        display: grid;
        grid-template-columns: 1fr auto auto;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: #fff9d9;
        border-radius: 10px;
        border: 1px solid #f6de7a;
      }
      .timeline-summary__label {
        font-weight: 700;
        color: #6b4c00;
        letter-spacing: 0.03em;
      }
      .timeline-summary__score {
        font-variant-numeric: tabular-nums;
        color: #4b3d09;
      }
      .timeline-summary__status {
        font-weight: 900;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: #2f6200;
      }
      .timeline-summary__status--loss {
        color: #9b1c1c;
      }
      .timeline-detail {
        margin-top: 12px;
        padding: 12px;
        background: rgba(8, 12, 26, 0.8);
        border: 1px solid rgba(108, 132, 205, 0.4);
        border-radius: 12px;
      }
      .timeline-detail__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.8rem;
      }
      .timeline-detail__title {
        font-weight: 800;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: var(--text-primary);
      }
      .close-detail {
        padding: 0.35rem 0.8rem;
      }
      .timeline-detail__controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        margin: 0.6rem 0;
      }
      .timeline-detail__quarter {
        font-size: 0.95rem;
        color: var(--text-muted);
        letter-spacing: 0.06em;
      }
      .timeline-detail__sides {
        display: inline-flex;
        gap: 0.5rem;
        background: rgba(108, 132, 205, 0.16);
        border-radius: 999px;
        padding: 0.2rem;
      }
      .timeline-detail__side {
        border: 1px solid transparent;
        background: transparent;
        color: var(--text-primary);
        padding: 0.35rem 0.9rem;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.06em;
        transition: all 120ms ease;
      }
      .timeline-detail__side--active {
        background: var(--accent);
        color: #0b111f;
        border-color: rgba(255, 255, 255, 0.14);
        box-shadow: 0 8px 20px rgba(70, 194, 255, 0.35);
      }
      .timeline-detail__table {
        display: grid;
        gap: 6px;
      }
      .timeline-detail__row {
        display: grid;
        grid-template-columns: 72px 1fr 1.3fr 70px;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 10px;
        border: 1px solid rgba(108, 132, 205, 0.2);
      }
      .timeline-detail__row--head {
        background: rgba(108, 132, 205, 0.12);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--text-muted);
      }
      .timeline-detail__cell {
        font-size: 0.92rem;
        color: var(--text-primary);
      }
      .timeline-detail__cell--muted {
        color: var(--text-muted);
      }
      .timeline-detail__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 1.05rem;
      }
      .timeline-detail__points {
        font-weight: 800;
        color: var(--accent);
        text-align: right;
      }

      .timeline-item {
        display: grid;
        grid-template-columns: 72px 1fr;
        gap: 0.8rem;
        align-items: start;
        border-left: 3px solid rgba(96, 108, 162, 0.35);
        padding-left: 0.6rem;
        border-radius: 12px;
        background: rgba(96, 108, 162, 0.08);
      }

      .timeline-item--kog {
        border-color: var(--accent);
        background: rgba(70, 194, 255, 0.14);
      }

      .timeline-item--opp {
        border-color: #f36c6c;
        background: rgba(243, 108, 108, 0.12);
      }

      .timeline-item--period {
        border-color: #f8d057;
        background: rgba(248, 208, 87, 0.16);
      }

      .timeline-label {
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.95rem;
      }

      .timeline-meta-row {
        color: var(--text-muted);
        font-size: 0.85rem;
        margin-top: 0.15rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
      }

      .timeline-time {
        text-align: right;
        color: var(--text-muted);
        font-size: 0.9rem;
      }

      .timeline-time span {
        display: block;
        font-size: 0.78rem;
        color: var(--accent);
        letter-spacing: 0.05em;
      }

      .timeline-content {
        position: relative;
        padding-left: 1.2rem;
      }

      .timeline-content::before {
        content: "";
        position: absolute;
        left: 0.35rem;
        top: 0.5rem;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 6px rgba(70, 194, 255, 0.12);
      }

      .timeline-label {
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }

      .timeline-meta-row {
        color: var(--text-muted);
        font-size: 0.9rem;
        margin-top: 0.15rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
      }

      .timeline-empty {
        color: var(--text-muted);
        text-align: center;
        padding: 1rem 0;
      }

      .stat-row span:first-child {
        color: var(--text-muted);
        text-transform: uppercase;
        font-size: 0.78rem;
        letter-spacing: 0.18em;
      }

      .stat-row strong {
        font-size: 1.2rem;
      }

      .stat-row.interactive {
        cursor: pointer;
      }

      .stat-row.interactive:hover strong,
      .stat-row.interactive:hover span {
        color: var(--accent);
      }
    </style>
  </head>
  <body>
    <main>
      <header></header>

      <section class="totals" id="teamTotals"></section>

      <section>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>No.</th>
                <th>Player</th>
                <th class="sortable" data-sort-key="gamesPlayed">Games</th>
                <th class="sortable" data-sort-key="freeThrowsMade">FT Made</th>
                <th class="sortable" data-sort-key="fieldGoalsMade">FG Made</th>
                <th class="sortable" data-sort-key="pointsPerGame">P/G</th>
                <th class="sortable" data-sort-key="totalPoints">Total Pts</th>
                <th class="sortable" data-sort-key="threePointsMade">3PT Made</th>
                <th class="sortable" data-sort-key="foulsMade">Fouls</th>
              </tr>
            </thead>
            <tbody id="statsTable"></tbody>
          </table>
        </div>
        <div class="no-data" id="noDataMessage">
          No stats available yet. Check back after the next Kungsholmen OG game tip-off.
        </div>
      </section>

      <section class="schedule" id="scheduleSection" hidden>
        <h2 class="schedule-title">Season Schedule</h2>
        <div class="next-game-wrapper" id="nextGameWrapper"></div>
        <div class="games-group" id="playedGamesGroup">
          <h3>Games Played</h3>
          <div class="games-list" id="playedGamesList"></div>
        </div>
        <div class="games-group" id="upcomingGamesGroup">
          <h3>Upcoming Games</h3>
          <div class="games-list" id="upcomingGamesList"></div>
        </div>
      </section>

      <section class="team-photo">
        <img src="assets/team-photo.png" alt="Kungsholmen OG team photo" />
      </section>

      <section class="links-card" id="linksCard" hidden>
        <h3>Links</h3>
        <div class="links-list" id="linksList"></div>
      </section>
    </main>
    <div class="modal-overlay" id="playerModal" aria-hidden="true">
      <div class="modal-card" role="dialog" aria-modal="true">
        <div class="modal-header">
          <h2 id="modalPlayerName"></h2>
          <button class="close-modal" id="closeModal" type="button">Close</button>
        </div>
        <div class="modal-badges" id="modalBadges"></div>
        <div class="modal-stats" id="modalStats"></div>
      </div>
    </div>
    <div class="modal-overlay" id="timelineModal" aria-hidden="true">
      <div class="modal-card modal-card--wide" role="dialog" aria-modal="true">
        <div class="modal-header">
          <h2 id="timelineTitle">Game Timeline</h2>
          <button class="close-modal" id="closeTimeline" type="button">Close</button>
        </div>
        <div class="timeline-controls">
          <input
            type="search"
            id="timelineSearch"
            placeholder="Filter by player name..."
            aria-label="Filter play-by-play by player name"
          />
        </div>
        <div class="timeline-meta" id="timelineMeta"></div>
        <div class="timeline-body" id="timelineBody"></div>
        <div class="timeline-summary" id="timelineSummary" hidden></div>
        <div class="timeline-detail" id="timelineDetail" hidden>
          <div class="timeline-detail__header">
            <div class="timeline-detail__title" id="timelineDetailTitle">Quarter detail</div>
            <button class="close-modal close-detail" id="closeDetail" type="button">Close</button>
          </div>
          <div class="timeline-detail__controls">
            <div class="timeline-detail__quarter" id="timelineDetailQuarter">Q1</div>
            <div class="timeline-detail__sides" id="timelineDetailSides">
              <button type="button" data-side="home" class="timeline-detail__side">H</button>
              <button type="button" data-side="away" class="timeline-detail__side">A</button>
            </div>
          </div>
          <div class="timeline-detail__table" id="timelineDetailTable"></div>
        </div>
      </div>
    </div>

    <script>
      const header = document.querySelector("header");
      const metaContainer = document.createElement("div");
      const scheduleSection = document.getElementById("scheduleSection");
      const nextGameWrapper = document.getElementById("nextGameWrapper");
      const playedGamesGroup = document.getElementById("playedGamesGroup");
      const playedGamesList = document.getElementById("playedGamesList");
      const upcomingGamesGroup = document.getElementById("upcomingGamesGroup");
      const upcomingGamesList = document.getElementById("upcomingGamesList");
      const linksCard = document.getElementById("linksCard");
      const linksList = document.getElementById("linksList");
      const timelineModal = document.getElementById("timelineModal");
      const timelineTitle = document.getElementById("timelineTitle");
      const timelineMeta = document.getElementById("timelineMeta");
      const timelineBody = document.getElementById("timelineBody");
      const timelineSummary = document.getElementById("timelineSummary");
      const timelineDetail = document.getElementById("timelineDetail");
      const timelineDetailTitle = document.getElementById("timelineDetailTitle");
      const timelineDetailQuarter = document.getElementById("timelineDetailQuarter");
      const timelineDetailSides = document.getElementById("timelineDetailSides");
      const timelineDetailTable = document.getElementById("timelineDetailTable");
      const closeDetailBtn = document.getElementById("closeDetail");
      const closeTimelineBtn = document.getElementById("closeTimeline");
      const timelineSearch = document.getElementById("timelineSearch");
      let playerStore = [];
      let scheduleStore = [];
      let timelineStore = [];
      let timelineContext = { homeOrAway: null };
      let quarterDetailsCache = {};
      let selectedQuarter = null;
      let selectedSide = "home";
      let sortState = { key: null, dir: "desc" };
      metaContainer.className = "meta";
      header.appendChild(
        (() => {
          const lockup = document.createElement("div");
          lockup.className = "team-lockup";
          lockup.innerHTML = `
            <img src="assets/team-logo.png" alt="Kungsholmen OG logo" class="team-logo" />
            <div class="team-lockup__text">
              <span>Season 2025</span>
              <h1>Kungsholmen OG</h1>
            </div>
          `;
          return lockup;
        })()
      );
      header.appendChild(metaContainer);

      const modalOverlay = document.getElementById("playerModal");
      const modalName = document.getElementById("modalPlayerName");
      const modalBadges = document.getElementById("modalBadges");
      const modalStats = document.getElementById("modalStats");
      const closeModalBtn = document.getElementById("closeModal");

      function createBadge(label, value, extraClass = "") {
        const badge = document.createElement("span");
        badge.className = extraClass ? `badge ${extraClass}` : "badge";
        badge.innerHTML = `<strong>${value}</strong>${label}`;
        return badge;
      }

      function formatDiff(diff) {
        if (diff > 0) return `+${diff}`;
        if (diff < 0) return `${diff}`;
        return `${diff}`;
      }

      const formatScoreLine = (record) => `${record.kogPoints}-${record.opponentPoints}`;

      function renderTotals(totals, gamesCount, playersTracked, teamRecords, playerRecords) {
        const cards = [
          { label: "Team Points", value: totals.totalPoints },
          { label: "Team Field Goals", value: totals.fieldGoals, metric: "fieldGoalsMade" },
          { label: "Team Free Throws", value: totals.freeThrows, metric: "freeThrowsMade" },
          { label: "Team 3PT", value: totals.threePointers, metric: "threePointsMade" },
          { label: "Games Logged", value: gamesCount },
          { label: "Players Tracked", value: playersTracked }
        ];

        const mostThrees = playerRecords?.mostThreesInGame;
        if (mostThrees && Number.isFinite(mostThrees.threePointers) && mostThrees.threePointers > 0) {
          const subtitleParts = [];
          if (mostThrees.player) subtitleParts.push(mostThrees.player);
          if (mostThrees.opponent) subtitleParts.push(`vs ${mostThrees.opponent}`);
          if (mostThrees.dateLabel) subtitleParts.push(mostThrees.dateLabel);

          const flameCount = Math.min(mostThrees.threePointers, 10);
          const flames = "ðŸ”¥".repeat(flameCount);
          cards.push({
            label: "Most 3PT (Game)",
            value: `${mostThrees.threePointers} ${flames}`,
            subtitle: subtitleParts.join(" â€” ") || null,
            metric: "threePointsMade"
          });
        }

        const mostPoints = playerRecords?.mostPointsInGame;
        if (mostPoints && Number.isFinite(mostPoints.points) && mostPoints.points > 0) {
          const subtitleParts = [];
          if (mostPoints.player) subtitleParts.push(mostPoints.player);
          if (mostPoints.opponent) subtitleParts.push(`vs ${mostPoints.opponent}`);
          if (mostPoints.dateLabel) subtitleParts.push(mostPoints.dateLabel);
          cards.push({
            label: "Most PTS (Game) ðŸ¥©",
            value: mostPoints.points,
            subtitle: subtitleParts.join(" â€” ") || null,
            metric: "totalPoints"
          });
        }

        if (teamRecords?.highestScore) {
          cards.push({
            label: "Highest Score",
            value: teamRecords.highestScore.kogPoints,
            subtitle: `vs ${teamRecords.highestScore.opponent} (${formatScoreLine(teamRecords.highestScore)})`
          });
        }

        if (teamRecords?.biggestWin) {
          cards.push({
            label: "Biggest Win",
            value: formatDiff(teamRecords.biggestWin.pointDiff),
            subtitle: `vs ${teamRecords.biggestWin.opponent} (${formatScoreLine(teamRecords.biggestWin)})`
          });
        }

        if (teamRecords?.toughestLoss) {
          cards.push({
            label: "Toughest Loss",
            value: formatDiff(teamRecords.toughestLoss.pointDiff),
            subtitle: `vs ${teamRecords.toughestLoss.opponent} (${formatScoreLine(teamRecords.toughestLoss)})`
          });
        }

        const totalsEl = document.getElementById("teamTotals");
        totalsEl.innerHTML = "";
        cards.forEach(({ label, value, subtitle, metric }) => {
          const card = document.createElement("article");
          const classes = ["totals-card"];
          if (metric) {
            classes.push("card-clickable");
            card.dataset.metric = metric;
            card.dataset.label = label;
            card.setAttribute("role", "button");
            card.tabIndex = 0;
          }
          card.className = classes.join(" ");
          card.innerHTML = `<span>${label}</span><strong>${value}</strong>${subtitle ? `<p>${subtitle}</p>` : ""}`;
          totalsEl.appendChild(card);
        });
      }

      function formatDateTime(value) {
        if (!value) return null;
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return null;
        return date.toLocaleString([], { dateStyle: "medium", timeStyle: "short" });
      }

      function getTipoffDate(game) {
        if (!game || !game.tipoff) return null;
        const date = new Date(game.tipoff);
        return Number.isNaN(date.getTime()) ? null : date;
      }

      function getTipoffTime(game, fallback = 0) {
        const date = getTipoffDate(game);
        return date ? date.getTime() : fallback;
      }

      function formatScheduleDate(game) {
        const date = getTipoffDate(game);
        if (!date) return game.dateLabel || "TBA";
        return date.toLocaleString([], {
          weekday: "short",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit"
        });
      }

      function formatCountdown(game) {
        const date = getTipoffDate(game);
        if (!date) return null;
        const diffMs = date.getTime() - Date.now();
        if (diffMs <= 0) return null;
        const diffHours = Math.round(diffMs / 36e5);
        if (diffHours >= 48) {
          const diffDays = Math.round(diffHours / 24);
          return `Starts in ${diffDays} ${diffDays === 1 ? "day" : "days"}`;
        }
        if (diffHours >= 1) {
          return `Starts in ${diffHours} ${diffHours === 1 ? "hour" : "hours"}`;
        }
        const diffMinutes = Math.max(1, Math.round(diffMs / 60000));
        return `Starts in ${diffMinutes} ${diffMinutes === 1 ? "minute" : "minutes"}`;
      }

      function buildGameCard(game, { highlight = false, label = null } = {}) {
        const card = document.createElement("article");
        card.className = highlight ? "game-card game-card--next" : "game-card";
        card.dataset.matchId = game.matchId;
        card.dataset.status = (game.status || "").toLowerCase();
        if (game.opponent) card.dataset.opponent = game.opponent;
        if (game.dateLabel) card.dataset.date = game.dateLabel;
        if (game.location) card.dataset.location = game.location;

        const headerRow = document.createElement("div");
        headerRow.className = "game-card__header";
        const effectiveLabel = label ?? (highlight ? "Next Game" : null);
        if (effectiveLabel) {
          const labelEl = document.createElement("span");
          labelEl.className = "game-card__label";
          labelEl.textContent = effectiveLabel;
          headerRow.appendChild(labelEl);
        } else {
          headerRow.appendChild(document.createElement("span"));
        }

        const badge = document.createElement("span");
        badge.className = "game-card__homeaway";
        badge.classList.add(game.homeOrAway === "home" ? "is-home" : "is-away");
        badge.textContent = game.homeOrAway === "home" ? "Home" : "Away";
        headerRow.appendChild(badge);
        card.appendChild(headerRow);

        const opponentLine = document.createElement("div");
        opponentLine.className = "game-card__opponent";
        const prefix = game.homeOrAway === "home" ? "vs" : "@";
        opponentLine.textContent = `${prefix} ${game.opponent || "TBD"}`;
        card.appendChild(opponentLine);

        const metaLine = document.createElement("div");
        metaLine.className = "game-card__meta";
        const metaParts = [];
        const formattedDate = formatScheduleDate(game);
        if (formattedDate) metaParts.push(formattedDate);
        if (game.location) metaParts.push(game.location);
        metaLine.textContent = metaParts.join(" â€¢ ") || "TBA";
        card.appendChild(metaLine);

        if (highlight) {
          const countdown = formatCountdown(game);
          if (countdown) {
            const countdownEl = document.createElement("div");
            countdownEl.className = "game-card__countdown";
            countdownEl.textContent = countdown;
            card.appendChild(countdownEl);
          }
        }

        const hasScore = Number.isFinite(game.kogScore) && Number.isFinite(game.opponentScore);
        if (hasScore) {
          const scoreRow = document.createElement("div");
          scoreRow.className = "game-card__score";
          scoreRow.innerHTML = `
            <span class="game-card__score-kog">${game.kogScore}</span>
            <span class="game-card__score-sep">-</span>
            <span class="game-card__score-opp">${game.opponentScore}</span>
          `;
          card.appendChild(scoreRow);

          const result = (game.result || "").toLowerCase();
          if (result) {
            const resultRow = document.createElement("div");
            resultRow.className = "game-card__result game-card__result--" + result;
            const diffLabel = Number.isFinite(game.pointDiff) ? formatDiff(game.pointDiff) : "";
            const resultLabel = result === "win" ? "Win" : result === "loss" ? "Loss" : "Draw";
            resultRow.textContent = diffLabel ? `${resultLabel} ${diffLabel}` : resultLabel;
            card.appendChild(resultRow);
          }
        }

        return card;
      }

      function renderSchedule(games) {
        scheduleStore = Array.isArray(games) ? games.slice() : [];
        nextGameWrapper.innerHTML = "";
        playedGamesList.innerHTML = "";
        upcomingGamesList.innerHTML = "";

        if (!Array.isArray(games) || !games.length) {
          scheduleSection.hidden = true;
          return;
        }

        scheduleSection.hidden = false;

        const now = Date.now();

        const played = games
          .filter((game) => (game.status || "").toLowerCase() === "played")
          .sort((a, b) => getTipoffTime(b, 0) - getTipoffTime(a, 0));

        const scheduled = games.filter((game) => (game.status || "").toLowerCase() !== "played");

        const upcomingFuture = scheduled
          .filter((game) => {
            const tipoffTime = getTipoffTime(game, Number.NaN);
            if (!Number.isFinite(tipoffTime)) return true;
            return tipoffTime >= now;
          })
          .sort((a, b) => getTipoffTime(a, Number.POSITIVE_INFINITY) - getTipoffTime(b, Number.POSITIVE_INFINITY));

        const staleUpcoming = scheduled
          .filter((game) => {
            const tipoffTime = getTipoffTime(game, Number.NaN);
            return Number.isFinite(tipoffTime) && tipoffTime < now;
          })
          .sort((a, b) => getTipoffTime(a, 0) - getTipoffTime(b, 0));

        let nextGame = null;
        let upcomingList = [];

        if (upcomingFuture.length) {
          [nextGame, ...upcomingList] = upcomingFuture;
        } else if (staleUpcoming.length) {
          [nextGame, ...upcomingList] = staleUpcoming;
        }

        if (nextGame) {
          nextGameWrapper.appendChild(buildGameCard(nextGame, { highlight: true }));
          nextGameWrapper.classList.add("active");
        } else {
          nextGameWrapper.classList.remove("active");
        }

        if (played.length) {
          playedGamesGroup.style.display = "";
          played.forEach((game) => {
            playedGamesList.appendChild(buildGameCard(game, { label: "Final" }));
          });
        } else {
          playedGamesGroup.style.display = "none";
        }

        if (upcomingList.length) {
          upcomingGamesGroup.style.display = "";
          upcomingList.forEach((game) => {
            upcomingGamesList.appendChild(buildGameCard(game));
          });
        } else {
          upcomingGamesGroup.style.display = "none";
        }
      }

      function renderLinks(links) {
        linksList.innerHTML = "";
        if (!Array.isArray(links) || !links.length) {
          linksCard.hidden = true;
          return;
        }

        links.forEach((link) => {
          if (!link || !link.url) return;
          const anchor = document.createElement("a");
          anchor.href = link.url;
          anchor.target = "_blank";
          anchor.rel = "noreferrer noopener";
          anchor.textContent = link.label || link.url;
          linksList.appendChild(anchor);
        });

        linksCard.hidden = linksList.children.length === 0;
      }

      function shortenTeamName(name) {
        if (!name) return "";
        const parts = name.split(/\s+/).filter(Boolean);
        if (parts.length <= 1) return parts[0];
        return parts.slice(-1)[0];
      }

      function formatPlayerShort(name) {
        if (!name) return "";
        const parts = name.split(/\s+/).filter(Boolean);
        if (!parts.length) return "";
        const [first, ...rest] = parts;
        const initials = rest.map((p) => `${p[0].toUpperCase()}.`).join("");
        return initials ? `${first} ${initials}` : first;
      }

      function parseScoreLine(line) {
        if (typeof line !== "string") return null;
        const parts = line.split("-");
        if (parts.length !== 2) return null;
        const [a, b] = parts.map((p) => parseInt(p.trim(), 10));
        if (Number.isNaN(a) || Number.isNaN(b)) return null;
        return [a, b];
      }

      function resolveSideKey(side) {
        const kogHome = (timelineContext.homeOrAway || "").toLowerCase() === "home";
        const homeSide = kogHome ? "kog" : "opponent";
        const sideKey = (side || "").toLowerCase();
        return sideKey === homeSide ? "home" : "away";
      }

      function buildQuarterDetails(timeline) {
        const QUARTER_POINTS = { 103: 3, 104: 2, 106: 1 };
        const cache = {};

        (timeline || []).forEach((event) => {
          const period = Number(event.period) || 0;
          if (!period || period > 4) return;
          if (event.kind === "period") return;

          const sideKey = resolveSideKey(event.side);
          const emoji = event.emoji || "";
          const points = QUARTER_POINTS[event.rawType] || 0;
          const name = (event.player || "").trim() || (event.teamName || "Unknown");
          const number = (event.playerNumber || "").toString().trim();

          const quarter = (cache[period] ||= { home: new Map(), away: new Map() });
          const bySide = quarter[sideKey];
          const playerKey = `${name}__${number}`;
          if (!bySide.has(playerKey)) {
            bySide.set(playerKey, {
              name,
              number,
              emojis: [],
              points: 0,
            });
          }
          const row = bySide.get(playerKey);
          if (emoji) row.emojis.push(emoji);
          row.points += points;
        });

        // convert maps to arrays for rendering
        Object.keys(cache).forEach((period) => {
          ["home", "away"].forEach((side) => {
            const entries = Array.from(cache[period][side].values());
            entries.sort((a, b) => b.points - a.points || a.name.localeCompare(b.name));
            cache[period][side] = entries;
          });
        });

        return cache;
      }

      function computeQuarterSummary(timeline) {
        if (!Array.isArray(timeline) || !timeline.length) return [];

        const periodState = new Map();
        let previousEnd = null;

        const getState = (period) => {
          if (!periodState.has(period)) {
            periodState.set(period, { start: null, end: null });
          }
          return periodState.get(period);
        };

        timeline.forEach((event) => {
          const period = Number(event.period) || 0;
          if (!period) return;

          if (event.kind === "period" && (event.label || "").startsWith("Start Period")) {
            const state = getState(period);
            if (state.start === null && previousEnd) {
              state.start = previousEnd;
            }
            return;
          }

          const score = parseScoreLine(event.score);
          if (score) {
            const state = getState(period);
            if (state.start === null) {
              state.start = previousEnd || score;
            }
            state.end = score;
          }

          if (event.kind === "period" && (event.label || "").startsWith("End Period")) {
            const state = getState(period);
            if (state.start === null) state.start = previousEnd || state.end;
            if (state.end === null) state.end = state.start;
            previousEnd = state.end || previousEnd;
          }
        });

        const summary = [];
        let carryEnd = null;
        [1, 2, 3, 4].forEach((period) => {
          const state = periodState.get(period) || { start: null, end: null };
          let start = state.start ?? carryEnd;
          let end = state.end ?? state.start ?? carryEnd;
          if (!start || !end) return;
          const [kogStart, oppStart] = start;
          const [kogEnd, oppEnd] = end;
          const kogQuarter = kogEnd - kogStart;
          const oppQuarter = oppEnd - oppStart;
          let outcome = "tie";
          if (kogQuarter > oppQuarter) outcome = "win";
          else if (kogQuarter < oppQuarter) outcome = "loss";
          summary.push({
            period,
            kogQuarter,
            oppQuarter,
            kogTotal: kogEnd,
            oppTotal: oppEnd,
            outcome,
          });
          carryEnd = end;
        });

        return summary;
      }

      function renderQuarterSummary(timeline) {
        const summary = computeQuarterSummary(timeline);
        timelineSummary.innerHTML = "";
        if (!summary.length) {
          timelineSummary.hidden = true;
          return;
        }

        const title = document.createElement("div");
        title.className = "timeline-summary__title";
        title.textContent = "Quarter breakdown";

        const rows = document.createElement("div");
        rows.className = "timeline-summary__rows";

        summary.forEach((row) => {
          const wrapper = document.createElement("div");
          wrapper.className = "timeline-summary__row";
          wrapper.dataset.period = row.period;

          const label = document.createElement("div");
          label.className = "timeline-summary__label";
          label.textContent = `Q${row.period}`;

          const score = document.createElement("div");
          score.className = "timeline-summary__score";
          score.textContent = `${row.kogQuarter}-${row.oppQuarter}`;

          const status = document.createElement("div");
          status.className = "timeline-summary__status";
          if (row.outcome === "loss") status.classList.add("timeline-summary__status--loss");
          const icon = row.outcome === "win" ? "âœ…" : row.outcome === "loss" ? "âŒ" : "âž–";
          status.textContent = `${icon} ${row.outcome === "win" ? "OG" : row.outcome === "loss" ? "Opp" : "Tie"}`;

          wrapper.appendChild(label);
          wrapper.appendChild(score);
          wrapper.appendChild(status);
          rows.appendChild(wrapper);

          wrapper.addEventListener("click", () => {
            selectedQuarter = row.period;
            timelineDetail.hidden = false;
            renderQuarterDetail();
          });
        });

        timelineSummary.appendChild(title);
        timelineSummary.appendChild(rows);
        timelineSummary.hidden = false;
      }

      function renderQuarterDetail() {
        if (!selectedQuarter) {
          timelineDetail.hidden = true;
          return;
        }

        timelineDetailQuarter.textContent = `Q${selectedQuarter}`;
        timelineDetailTitle.textContent = selectedSide === "home" ? "Home quarter detail" : "Away quarter detail";

        Array.from(timelineDetailSides.querySelectorAll(".timeline-detail__side")).forEach((btn) => {
          if (btn.dataset.side === selectedSide) {
            btn.classList.add("timeline-detail__side--active");
          } else {
            btn.classList.remove("timeline-detail__side--active");
          }
        });

        const data = quarterDetailsCache[selectedQuarter]?.[selectedSide] || [];
        timelineDetailTable.innerHTML = "";

        const head = document.createElement("div");
        head.className = "timeline-detail__row timeline-detail__row--head";
        head.innerHTML = `
          <div class="timeline-detail__cell">No.</div>
          <div class="timeline-detail__cell">Player</div>
          <div class="timeline-detail__cell">Actions</div>
          <div class="timeline-detail__cell timeline-detail__points">Pts</div>
        `;
        timelineDetailTable.appendChild(head);

        if (!data.length) {
          const empty = document.createElement("div");
          empty.className = "timeline-detail__row";
          empty.innerHTML = `
            <div class="timeline-detail__cell timeline-detail__cell--muted" style="grid-column: 1 / -1; text-align: center;">
              No player actions logged for this quarter.
            </div>
          `;
          timelineDetailTable.appendChild(empty);
          return;
        }

        data.forEach((row) => {
          const item = document.createElement("div");
          item.className = "timeline-detail__row";
          const numberLabel = row.number ? `#${row.number}` : "â€”";
          const actions = row.emojis.length ? row.emojis.join(" ") : "â€”";
          item.innerHTML = `
            <div class="timeline-detail__cell">${numberLabel}</div>
            <div class="timeline-detail__cell">${formatPlayerShort(row.name)}</div>
            <div class="timeline-detail__cell timeline-detail__actions">${actions}</div>
            <div class="timeline-detail__cell timeline-detail__points">${row.points}</div>
          `;
          timelineDetailTable.appendChild(item);
        });
      }

      function renderTimeline(timeline, filterTerm = "") {
        timelineBody.innerHTML = "";
        if (!Array.isArray(timeline) || !timeline.length) {
          timelineBody.innerHTML = `<div class="timeline-empty">No play-by-play data for this game yet.</div>`;
          timelineSummary.hidden = true;
          timelineSummary.innerHTML = "";
          timelineDetail.hidden = true;
          selectedQuarter = null;
          return;
        }

        const term = (filterTerm || "").trim().toLowerCase();
        const filtered = term
          ? timeline.filter((event) => (event.player || "").toLowerCase().includes(term))
          : timeline;

        if (!filtered.length) {
          timelineBody.innerHTML = `<div class="timeline-empty">No events matched that player.</div>`;
          timelineSummary.hidden = true;
          timelineSummary.innerHTML = "";
          timelineDetail.hidden = true;
          selectedQuarter = null;
          return;
        }

        filtered.forEach((event) => {
          const item = document.createElement("div");
          const sideClass =
            event.kind === "period"
              ? "timeline-item timeline-item--period"
              : (event.side || "").toLowerCase() === "kog"
              ? "timeline-item timeline-item--kog"
              : "timeline-item timeline-item--opp";
          item.className = sideClass;
          const periodLabel = event.period ? `Q${event.period}` : "â€”";

          const teamShort =
            event.side === "KOG"
              ? "OG"
              : shortenTeamName(event.teamName) || (event.teamName ? event.teamName : "Opp");
          const scoreLabel = event.score ? `[${event.score}]` : "";
          const playerLabel = formatPlayerShort(event.player);
          const playerNumber = event.playerNumber ? ` #${event.playerNumber}` : "";
          const headline = [scoreLabel, teamShort, playerLabel ? `, ${playerLabel}${playerNumber}` : ""]
            .filter(Boolean)
            .join(" ")
            .trim();

          item.innerHTML = `
            <div class="timeline-time">
              ${event.clock || "â€”"}
              <span>${periodLabel}</span>
            </div>
            <div class="timeline-content">
              <div class="timeline-label">${event.emoji || "â€¢"} ${headline || event.label || "Event"}</div>
              <div class="timeline-meta-row">${event.detail || event.label || ""}</div>
            </div>
          `;
          timelineBody.appendChild(item);
        });

        renderQuarterSummary(timelineStore);
      }

      function openTimelineModal(matchId, gameInfo = null) {
        if (!matchId) return;
        timelineModal.classList.add("visible");
        timelineModal.setAttribute("aria-hidden", "false");
        document.body.style.overflow = "hidden";
        timelineSearch.value = "";
        timelineStore = [];

        const titleOpponent = gameInfo?.opponent || "Opponent";
        timelineTitle.textContent = `vs ${titleOpponent}`;

        const metaBits = [];
        if (gameInfo?.dateLabel) metaBits.push(gameInfo.dateLabel);
        if (gameInfo?.location) metaBits.push(gameInfo.location);
        if (Number.isFinite(gameInfo?.kogScore) && Number.isFinite(gameInfo?.opponentScore)) {
          metaBits.push(`Final ${gameInfo.kogScore}-${gameInfo.opponentScore}`);
        } else if (Number.isFinite(gameInfo?.kogScore) || Number.isFinite(gameInfo?.opponentScore)) {
          metaBits.push(`Score ${gameInfo.kogScore ?? "-"}-${gameInfo.opponentScore ?? "-"}`);
        }
        timelineMeta.textContent = metaBits.join(" â€¢ ");
        timelineBody.innerHTML = `<div class="timeline-empty">Loading play-by-playâ€¦</div>`;
        timelineSummary.hidden = true;
        timelineDetail.hidden = true;
        selectedQuarter = null;
        selectedSide = "home";

        fetch(`data/playbyplay/game_${matchId}.json`, { cache: "no-store" })
          .then((response) => (response.ok ? response.json() : null))
          .then((data) => {
            if (!data || !data.timeline) {
              timelineBody.innerHTML = `<div class="timeline-empty">No play-by-play data for this game.</div>`;
              return;
            }
            timelineStore = data.timeline;
            timelineContext = { homeOrAway: data.homeOrAway || null };
            quarterDetailsCache = buildQuarterDetails(timelineStore);
            renderTimeline(timelineStore);
            renderQuarterSummary(timelineStore);
            selectedQuarter = 1;
            selectedSide = "home";
            renderQuarterDetail();
          })
          .catch(() => {
            timelineBody.innerHTML = `<div class="timeline-empty">No play-by-play data for this game.</div>`;
          });
      }

      function closeTimelineModal() {
        timelineModal.classList.remove("visible");
        timelineModal.setAttribute("aria-hidden", "true");
        document.body.style.overflow = "";
        timelineDetail.hidden = true;
        selectedQuarter = null;
      }

      function renderBadges(players, metadata, gamesCount) {
        metaContainer.innerHTML = "";
        metaContainer.appendChild(createBadge("Games Logged", gamesCount));

        const compareBy = (key) =>
          players
            .slice()
            .sort(
              (a, b) =>
                (b[key] ?? 0) - (a[key] ?? 0) || a.name.localeCompare(b.name)
            )[0];

        const bestScorer = players.length ? compareBy("totalPoints") : null;
        const bestThree = players.length ? compareBy("threePointsMade") : null;
        const topFouler = players.length ? compareBy("foulsMade") : null;

        bestScorer && bestScorer.totalPoints > 0 && metaContainer.appendChild(createBadge("Top Scorer ðŸª£", bestScorer.name));
        bestThree && bestThree.threePointsMade > 0 && metaContainer.appendChild(createBadge("Top 3PT ðŸ‘Œ", bestThree.name));
        topFouler && topFouler.foulsMade > 0 && metaContainer.appendChild(createBadge("Top Fouler ðŸ©¼", topFouler.name));

        const updated = formatDateTime(metadata && metadata.generatedAt);
        if (updated) {
          metaContainer.appendChild(createBadge("Updated", updated));
        }
      }

      function updateSortHeaders() {
        document.querySelectorAll("th[data-sort-key]").forEach((th) => {
          const key = th.dataset.sortKey;
          if (sortState.key === key) {
            th.dataset.active = "true";
            th.dataset.direction = sortState.dir;
          } else {
            th.dataset.active = "false";
            th.dataset.direction = "";
          }
        });
      }

      function renderTable(players) {
        const tbody = document.getElementById("statsTable");
        tbody.innerHTML = "";

        const metrics = [
          "gamesPlayed",
          "freeThrowsMade",
          "fieldGoalsMade",
          "pointsPerGame",
          "totalPoints",
          "threePointsMade",
          "foulsMade",
        ];

        const sortedPlayers = (() => {
          if (!sortState.key) return players.slice();
          const dir = sortState.dir === "asc" ? 1 : -1;
          return players
            .slice()
            .sort((a, b) => {
              const av = Number(a[sortState.key]) || 0;
              const bv = Number(b[sortState.key]) || 0;
              const delta = (av - bv) * dir;
              if (delta !== 0) return delta;
              return a.name.localeCompare(b.name);
            });
        })();

        const maxima = metrics.reduce((acc, key) => {
          const values = players.map((p) => Number(p[key]) || 0);
          acc[key] = values.length ? Math.max(...values) : 0;
          return acc;
        }, {});

        sortedPlayers.forEach((player) => {
          const row = document.createElement("tr");
          const pointsPerGame = player.gamesPlayed
            ? (player.totalPoints / player.gamesPlayed).toFixed(1)
            : "0.0";

          const cells = [
            { value: player.gamesPlayed, key: "gamesPlayed", display: player.gamesPlayed },
            { value: player.freeThrowsMade, key: "freeThrowsMade", display: player.freeThrowsMade },
            { value: player.fieldGoalsMade, key: "fieldGoalsMade", display: player.fieldGoalsMade },
            {
              value: parseFloat(pointsPerGame),
              key: "pointsPerGame",
              display: pointsPerGame,
            },
            { value: player.totalPoints, key: "totalPoints", display: player.totalPoints },
            {
              value: player.threePointsMade,
              key: "threePointsMade",
              display: player.threePointsMade,
            },
            { value: player.foulsMade, key: "foulsMade", display: player.foulsMade },
          ];

          row.innerHTML = `
            <td class="number">#${player.number || "-"}</td>
            <td>
              ${player.name}
              <span>${player.gamesPlayed ? "Active" : "DNP"}</span>
            </td>
            ${cells
              .map(({ display }) => `<td>${Number.isFinite(display) ? display : display || 0}</td>`)
              .join("")}
          `;

          const tds = row.querySelectorAll("td");
          cells.forEach(({ value, key }, index) => {
            if (value === maxima[key] && maxima[key] > 0) {
              tds[index + 2].classList.add("highlight");
            }
          });

          row.dataset.name = player.name;
          row.dataset.number = player.number || "-";
          row.dataset.games = player.gamesPlayed;
          row.dataset.freeThrows = player.freeThrowsMade;
          row.dataset.fieldGoals = player.fieldGoalsMade;
          row.dataset.pointsPerGame = pointsPerGame;
          row.dataset.totalPoints = player.totalPoints;
          row.dataset.threePoints = player.threePointsMade;
          row.dataset.fouls = player.foulsMade;

          tbody.appendChild(row);
        });

        updateSortHeaders();
      }

      function computeTeamTotals(players) {
        return players.reduce(
          (acc, player) => {
            acc.totalPoints += player.totalPoints;
            acc.fieldGoals += player.fieldGoalsMade;
            acc.freeThrows += player.freeThrowsMade;
            acc.threePointers += player.threePointsMade;
            return acc;
          },
          { totalPoints: 0, fieldGoals: 0, freeThrows: 0, threePointers: 0 }
        );
      }

      function resolveGamesCount(players, metadata) {
        if (metadata && Array.isArray(metadata.gamesProcessed) && metadata.gamesProcessed.length) {
          return metadata.gamesProcessed.length;
        }
        const counts = players.map((p) => p.gamesPlayed || 0).filter((num) => num > 0);
        return counts.length ? Math.max(...counts) : 0;
      }

      Promise.all([
        fetch("data/kog_players.json", { cache: "no-store" })
          .then((response) => (response.ok ? response.json() : []))
          .catch(() => []),
        fetch("data/last_updated.json", { cache: "no-store" })
          .then((response) => (response.ok ? response.json() : null))
          .catch(() => null),
        fetch("data/kog_schedule.json", { cache: "no-store" })
          .then((response) => (response.ok ? response.json() : []))
          .catch(() => []),
        fetch("data/kog_links.json", { cache: "no-store" })
          .then((response) => (response.ok ? response.json() : []))
          .catch(() => [])
      ])
        .then(([playersData, metadata, scheduleData, linksData]) => {
          const players = Array.isArray(playersData) ? playersData : [];
          const gamesCount = resolveGamesCount(players, metadata);
          const playersTracked = metadata && typeof metadata.playersTracked === "number"
            ? metadata.playersTracked
            : players.length;

          playerStore = players;

          renderBadges(players, metadata, gamesCount);
          renderSchedule(Array.isArray(scheduleData) ? scheduleData : []);
          renderLinks(Array.isArray(linksData) ? linksData : []);

          if (!players.length) {
            document.getElementById("noDataMessage").style.display = "block";
            return;
          }

          renderTable(players);
          renderTotals(
            computeTeamTotals(players),
            gamesCount,
            playersTracked,
            metadata?.teamRecords || null,
            metadata?.playerRecords || null
          );
        })
        .catch(() => {
          document.getElementById("noDataMessage").style.display = "block";
          renderBadges([], null, 0);
          renderSchedule([]);
          renderLinks([]);
        });

      function openPlayerModal(data) {
        modalName.textContent = data.name;

        modalBadges.innerHTML = "";
        if (data.number && data.number !== "-") {
          modalBadges.appendChild(createBadge("Jersey", `#${data.number}`));
        }
        modalBadges.appendChild(createBadge("Total Pts", data.totalPoints, "badge--hero"));
        modalBadges.appendChild(createBadge("PTS/G", data.pointsPerGame, "badge--hero"));

        const statConfig = [
          { label: "Games Played", value: data.games },
          { label: "Free Throws Made", value: data.freeThrows },
          { label: "Field Goals Made", value: data.fieldGoals },
          { label: "Three Pointers", value: data.threePoints },
          { label: "Fouls Committed", value: data.fouls }
        ];

        modalStats.innerHTML = "";
        statConfig.forEach(({ label, value }) => {
          const row = document.createElement("div");
          row.className = "stat-row";
          row.innerHTML = `<span>${label}</span><strong>${value}</strong>`;
          modalStats.appendChild(row);
        });

        modalOverlay.classList.add("visible");
        modalOverlay.setAttribute("aria-hidden", "false");
      }

      function openTeamModal(metric, title) {
        const players = playerStore
          .filter((player) => (player[metric] ?? 0) > 0)
          .sort((a, b) => (b[metric] ?? 0) - (a[metric] ?? 0));

        modalName.textContent = title;
        modalBadges.innerHTML = "";

        const totalValue = players.reduce((acc, player) => acc + (player[metric] ?? 0), 0);
        modalBadges.appendChild(createBadge("Team Total", totalValue, "badge--hero"));

        modalStats.innerHTML = "";
        if (!players.length) {
          const emptyRow = document.createElement("div");
          emptyRow.className = "stat-row";
          emptyRow.innerHTML = `<span>No data yet</span><strong>0</strong>`;
          modalStats.appendChild(emptyRow);
        } else {
          players.forEach((player) => {
            const value = player[metric] ?? 0;
            const row = document.createElement("div");
            row.className = "stat-row interactive";
            row.dataset.name = player.name;
            row.dataset.number = player.number || "-";
            row.dataset.games = player.gamesPlayed;
            row.dataset.freeThrows = player.freeThrowsMade;
            row.dataset.fieldGoals = player.fieldGoalsMade;
            row.dataset.pointsPerGame = player.pointsPerGame;
            row.dataset.totalPoints = player.totalPoints;
            row.dataset.threePoints = player.threePointsMade;
            row.dataset.fouls = player.foulsMade;
            row.innerHTML = `<span>${player.name}</span><strong>${value}</strong>`;
            row.addEventListener("click", () => openPlayerModal(row.dataset));
            modalStats.appendChild(row);
          });
        }

        modalOverlay.classList.add("visible");
        modalOverlay.setAttribute("aria-hidden", "false");
      }

      function closeModal() {
        modalOverlay.classList.remove("visible");
        modalOverlay.setAttribute("aria-hidden", "true");
      }

      document.getElementById("statsTable").addEventListener("click", (event) => {
        const row = event.target.closest("tr");
        if (!row) return;
        openPlayerModal(row.dataset);
      });

      document.querySelectorAll("th[data-sort-key]").forEach((th) => {
        th.addEventListener("click", () => {
          const key = th.dataset.sortKey;
          if (!key) return;
          if (sortState.key === key) {
            sortState.dir = sortState.dir === "desc" ? "asc" : "desc";
          } else {
            sortState.key = key;
            sortState.dir = "desc";
          }
          renderTable(playerStore);
        });
      });

      scheduleSection.addEventListener("click", (event) => {
        const card = event.target.closest(".game-card");
        if (!card) return;
        const status = (card.dataset.status || "").toLowerCase();
        if (status !== "played") return;
        const matchId = Number(card.dataset.matchId);
        if (!matchId) return;
        const game =
          scheduleStore.find((g) => Number(g.matchId) === matchId) || {
            opponent: card.dataset.opponent,
            dateLabel: card.dataset.date,
            location: card.dataset.location
          };
        openTimelineModal(matchId, game);
      });

      const teamTotalsEl = document.getElementById("teamTotals");
      const handleTotalsActivation = (card) => {
        if (!card) return;
        const metric = card.dataset.metric;
        if (!metric) return;
        const label = card.dataset.label || "Team Stat";
        openTeamModal(metric, `${label} Breakdown`);
      };

      teamTotalsEl.addEventListener("click", (event) => {
        const card = event.target.closest(".card-clickable");
        handleTotalsActivation(card);
      });

      teamTotalsEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          const card = event.target.closest(".card-clickable");
          if (!card) return;
          event.preventDefault();
          handleTotalsActivation(card);
        }
      });

      timelineDetailSides.addEventListener("click", (event) => {
        const btn = event.target.closest("button[data-side]");
        if (!btn) return;
        selectedSide = btn.dataset.side === "away" ? "away" : "home";
        renderQuarterDetail();
      });

      closeDetailBtn.addEventListener("click", () => {
        timelineDetail.hidden = true;
        selectedQuarter = null;
      });

      closeModalBtn.addEventListener("click", closeModal);
      modalOverlay.addEventListener("click", (event) => {
        if (event.target === modalOverlay) {
          closeModal();
        }
      });
      closeTimelineBtn.addEventListener("click", closeTimelineModal);
      timelineModal.addEventListener("click", (event) => {
        if (event.target === timelineModal) {
          closeTimelineModal();
        }
      });

      timelineSearch.addEventListener("input", (event) => {
        const term = event.target.value || "";
        renderTimeline(timelineStore, term);
      });
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && modalOverlay.classList.contains("visible")) {
          closeModal();
        }
      });
    </script>
  </body>
</html>
